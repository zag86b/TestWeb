<!DOCTYPE html>

<html lang="en">
<head>
    <!-- Google ad (gtag.js) -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8764257308898767"
     crossorigin="anonymous"></script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-GYTVB75FB1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GYTVB75FB1');
</script>
<!-- Google tag (gtag.js) end -->
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Debt Avalanche Calculator - CalcBed.com</title>
<meta content="Calculate your debt avalanche repayment plan with rolling payments and fixed total payment. Optimize your debt payoff and save on interest." name="description"/>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
    /* Template base styling */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Roboto, sans-serif;
      background-color: #fff;
      color: #333;
      line-height: 1.6;
    }

    header {
      background: #f8f9fa;
      padding: 1rem 2rem;
      border-bottom: 1px solid #ddd;
      position: relative;
    }

    nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }

    nav h1 a {
      font-size: 1.5rem;
      color: #222;
      text-decoration: none;
    }

    .menu-toggle {
      display: none;
      font-size: 1.5rem;
      cursor: pointer;
      border: none;
      background: none;
    }

    .nav-links {
      display: flex;
      gap: 1rem;
      list-style: none;
      align-items: center;
      position: relative;
    }

    .nav-links li {
      position: relative;
    }

    .nav-links a {
      text-decoration: none;
      color: #555;
      font-weight: 500;
      padding: 0.5rem;
      display: block;
    }

    .dropdown-menu {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;       /* default alignment */
      right: auto;   /* reset flipped position */
      background: #fff;
      border: 1px solid #ddd;
      min-width: 220px;
      max-width: 90vw;
      overflow-x: auto;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .dropdown-menu li {
      width: 100%;
    }

    .dropdown-menu a {
      padding: 0.6rem 1rem;
      display: block;
      text-decoration: none;
      color: #333;
      white-space: normal; /* allow wrap */
      word-wrap: break-word;
      font-size: 0.95rem;
    }

    .dropdown-menu a:hover {
      background-color: #f0f0f0;
    }

    .dropdown:hover .dropdown-menu {
      display: block;
    }

    .page-container {
      display: flex;
      justify-content: center;
      padding: 1rem;
      gap: 1rem;
    }

    .ad-sidebar {
      width: 120px;
      flex-shrink: 0;
      display: block;
    }

    .main-content {
      max-width: 900px; /* Adjusted for calculator content */
      flex: 1;
      padding: 0 1rem;
      margin: 40px auto; /* Centered with top/bottom margin */
      background: #fff;
      color: #1d1d1f;
      line-height: 1.5;
    }

    .hero {
      text-align: center;
      padding: 3rem 1rem;
    }

    .hero h2 {
      font-size: 2.5rem;
      margin-bottom: 1rem;
    }

    .hero p {
      font-size: 1.2rem;
      color: #666;
    }

    footer {
      background: #f1f1f1;
      padding: 1rem;
      text-align: center;
      font-size: 0.9rem;
      color: #777;
    }

    /* Calculator Specific Styling (from DevAvalanche007.html) */
    .main-content h1, .main-content h2 { /* Targeting h1, h2 specifically in main-content */
      font-weight: 600;
      margin-bottom: 12px;
      color: #111;
    }
    .main-content h1 {
      font-size: 2.2rem;
      margin-bottom: 24px;
      text-align: center;
    }
    .main-content h2 {
      font-size: 1.5rem;
      border-bottom: 1px solid #e5e5ea;
      padding-bottom: 8px;
      margin-top: 48px;
      margin-bottom: 16px;
    }
    label {
      display: block;
      font-weight: 500;
      margin-bottom: 8px;
      color: #3a3a3c;
    }
    input[type="number"], input[type="text"] { /* Added text type */
      width: 100%;
      padding: 8px 10px;
      font-size: 1rem;
      border: 1px solid #d2d2d7;
      border-radius: 8px;
      outline-offset: 2px;
      transition: border-color 0.15s ease-in-out;
      box-sizing: border-box;
      background: #fafafa;
      color: #1d1d1f;
    }
    input[type="number"]:focus, input[type="text"]:focus {
      border-color: #0071e3;
      background: #fff;
    }
    select {
      width: 100%;
      padding: 8px 10px;
      font-size: 1rem;
      border: 1px solid #d2d2d7;
      border-radius: 8px;
      background: #fafafa;
      color: #1d1d1f;
      outline-offset: 2px;
      cursor: pointer;
      transition: border-color 0.15s ease-in-out;
      box-sizing: border-box;
    }
    select:focus {
      border-color: #0071e3;
      background: #fff;
    }
    .main-content table { /* Targeted table to avoid conflicts with nav table */
      width: 100%;
      border-collapse: separate;
      border-spacing: 0 10px;
      margin-top: 16px;
      font-size: 1rem;
      color: #1d1d1f;
      overflow-x: auto;
      display: block;
      white-space: nowrap;
    }
    .main-content thead tr {
      border-bottom: 2px solid #e5e5ea;
    }
    .main-content th, .main-content td {
      text-align: center;
      padding: 10px 8px;
      min-width: 80px;
    }
    .main-content th {
      font-weight: 600;
      color: #6e6e73;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      font-size: 0.85rem;
      background: #f9f9fa;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .main-content tbody tr {
      background: #f7f7f8;
      border-radius: 12px;
      transition: background 0.2s ease-in-out;
      display: table-row;
    }
    .main-content tbody tr:hover {
      background: #e9e9eb;
    }
    button {
      font-weight: 600;
      font-size: 1rem;
      color: #0071e3;
      background: transparent;
      border: 2px solid #0071e3;
      border-radius: 12px;
      padding: 10px 18px;
      cursor: pointer;
      margin: 10px 6px 30px 0;
      transition: background 0.25s ease, color 0.25s ease;
    }
    button:hover {
      background: #0071e3;
      color: #fff;
    }
    button:active {
      background: #005bb5;
      border-color: #005bb5;
    }
    #minimumSummary {
      background: #fafafa;
      border: 1px solid #e5e5ea;
      border-radius: 12px;
      padding: 20px;
      color: #3a3a3c;
      font-size: 1rem;
      line-height: 1.4;
      margin-top: 16px;
      box-shadow: 0 1px 3px rgb(60 64 67 / 0.1);
    }
    canvas {
      margin-top: 32px;
      border-radius: 12px;
      box-shadow: 0 1px 4px rgb(60 64 67 / 0.15);
      background: #fff;
      max-width: 100%;
      height: 320px !important;
    }

    /* Quick Guide Styling */
    .quick-guide {
      background: #f0f2f5; /* Light grey background */
      border: 1px solid #e0e2e5;
      border-radius: 12px;
      padding: 20px 25px;
      margin-bottom: 30px;
      color: #3a3a3c;
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .quick-guide h3 {
      font-weight: 600;
      font-size: 1.25rem;
      margin-bottom: 15px;
      color: #111;
      text-align: center;
    }

    .quick-guide ul {
      list-style: none; /* Remove default bullets */
      padding: 0;
      margin: 0;
    }

    .quick-guide li {
      margin-bottom: 10px;
      padding-left: 25px;
      position: relative;
    }

    .quick-guide li::before {
      content: '•'; /* Custom bullet */
      color: #0071e3; /* Blue bullet */
      font-weight: bold;
      display: inline-block;
      width: 1em;
      margin-left: -1em;
      position: absolute;
      left: 0;
      top: 0;
    }

    .quick-guide p {
      margin-top: 20px;
      font-size: 0.9rem;
      color: #6e6e73;
      text-align: center;
    }


    /* Responsive adjustments for template */
    @media (max-width: 900px) {
      .ad-sidebar {
        display: none;
      }

      .main-content {
        max-width: 100%;
        padding: 0 20px; /* Adjust padding for smaller screens */
        margin: 20px auto; /* Adjust margin for smaller screens */
      }

      .menu-toggle {
        display: block;
      }

      .nav-links {
        display: none;
        flex-direction: column;
        width: 100%;
        background: #f8f9fa;
        margin-top: 1rem;
      }

      .nav-links.active {
        display: flex;
      }

      .dropdown-menu {
        position: static;
        border: none;
        box-shadow: none;
        max-width: 100%;
        overflow-x: visible;
      }

      .dropdown:hover .dropdown-menu {
        display: none;
      }

      .dropdown.open .dropdown-menu {
        display: block;
      }
    }
  </style>
<script>
    document.addEventListener('DOMContentLoaded', () => {
      const toggle = document.querySelector('.menu-toggle');
      const navLinks = document.querySelector('.nav-links');
      const dropdowns = document.querySelectorAll('.dropdown');

      toggle.addEventListener('click', () => {
        navLinks.classList.toggle('active');
      });

      dropdowns.forEach(drop => {
        drop.addEventListener('click', function (e) {
          if (window.innerWidth <= 900) {
            e.stopPropagation();
            e.preventDefault();
            drop.classList.toggle('open');
          }
        });
      });

      // Flip dropdown menu if overflowing viewport on desktop hover
      dropdowns.forEach(drop => {
        drop.addEventListener('mouseenter', () => {
          if (window.innerWidth <= 900) return; // skip mobile

          const menu = drop.querySelector('.dropdown-menu');
          if (!menu) return;

          // Reset position
          menu.style.left = '0';
          menu.style.right = 'auto';

          const rect = menu.getBoundingClientRect();
          const overflowRight = rect.right - window.innerWidth;

          if (overflowRight > 0) {
            // Flip dropdown to open leftwards
            menu.style.left = 'auto';
            menu.style.right = '0';
          }
        });

        drop.addEventListener('mouseleave', () => {
          const menu = drop.querySelector('.dropdown-menu');
          if (!menu) return;
          menu.style.left = '0';
          menu.style.right = 'auto';
        });
      });
    });
  </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script></head>
<body>
<header>
<nav>
<h1><a href="https://www.calcbed.com">CalcBed.com</a></h1>
<button aria-label="Toggle navigation" class="menu-toggle">☰</button>
<ul class="nav-links">
<li><a href="https://www.calcbed.com">Home</a></li>
<li class="dropdown">
<a href="#">Finance ▾</a>
<ul class="dropdown-menu">
<li><a href="CAGR.html">CAGR</a></li>
<li><a href="PIR.html">Personalised Investment Return</a></li>
<li><a href="DebtAvalanche.html">Debt Avalanche</a></li>
<li><a href="DebtSnowball.html">Debt Snowball</a></li>
</ul>
</li>
</ul>
</nav>
</header>
<div class="page-container">
<aside class="ad-sidebar">
</aside>
<main class="main-content">
<h1>Debt Avalanche Calculator with Rolling Payments &amp; Fixed Total Payment</h1>
<div class="quick-guide">
<h3>Quick Guide: Understanding Your Debt Avalanche</h3>
<ul>
<li>The Debt Avalanche method prioritizes paying off debts with the **highest interest rates first**. This strategy aims to **minimize the total interest you pay** over the life of your debts, saving you money in the long run.</li>
<li>This calculator will produce an **estimated payment schedule**, showing how your fixed total monthly payment (your minimums plus any extra overpayment) is allocated to each debt. As one debt is paid off, the payment amount for that debt is "rolled" into the next highest-interest debt, accelerating your payoff.</li>
<li>**Please note:** This calculator provides **guidance only** and is not financial advice. It is your responsibility to ensure all minimum payments on your debts are met, regardless of the projected schedule here. Interest rates can change, and unforeseen circumstances may impact your ability to pay. Always refer to your official statements for precise figures and due dates.</li>
<li>Results are based on the information you input and assume consistent payments. Small discrepancies may occur due to rounding or specific lender calculations.</li>
</ul>
<p>Take control of your debt, understand your payoff journey, and see your potential savings!</p>
</div>
<label for="extraBudget">Extra Overpayment (£):</label>
<input id="extraBudget" placeholder="Enter extra amount available for debt repayment" step="0.01" type="number"/>
<table>
<thead>
<tr>
<th>Creditor</th>
<th>Balance (£)</th>
<th>Interest Rate (%)</th>
<th>Min Payment</th>
<th>Type (£ or %)</th>
<th>Remove</th>
</tr>
</thead>
<tbody id="debtBody"></tbody>
</table>
<button onclick="addDebt()">+ Add Debt</button>
<button onclick="calculate()">Calculate</button>
<h2>Estimated Payoff Duration with Minimum Payments</h2>
<div id="minimumSummary"></div>
<h2>Balance Over Time</h2>
<canvas id="balanceLineChart"></canvas>
<h2>Payment Schedule (Monthly Payments)</h2>
<div style="overflow-x:auto;">
<table id="paymentScheduleTable">
<thead><tr></tr></thead>
<tbody></tbody>
</table>
</div>
<h2>Balance Schedule (Remaining Balances)</h2>
<div style="overflow-x:auto;">
<table id="balanceScheduleTable">
<thead><tr></tr></thead>
<tbody></tbody>
</table>
</div>
<div style="text-align:center; margin: 2rem 0;">
<button onclick="downloadPDF()">Download PDF</button></div>
</main>
<aside class="ad-sidebar">
</aside>
</div>
<footer>
    © 2025 CalcBed.com - Built with ❤️ for everyday problems.
  </footer>
<script>
    // Existing Template JavaScript
    document.addEventListener('DOMContentLoaded', () => {
      const toggle = document.querySelector('.menu-toggle');
      const navLinks = document.querySelector('.nav-links');
      const dropdowns = document.querySelectorAll('.dropdown');

      toggle.addEventListener('click', () => {
        navLinks.classList.toggle('active');
      });

      dropdowns.forEach(drop => {
        drop.addEventListener('click', function (e) {
          if (window.innerWidth <= 900) {
            e.stopPropagation();
            e.preventDefault();
            drop.classList.toggle('open');
          }
        });
      });

      // Flip dropdown menu if overflowing viewport on desktop hover
      dropdowns.forEach(drop => {
        drop.addEventListener('mouseenter', () => {
          if (window.innerWidth <= 900) return; // skip mobile

          const menu = drop.querySelector('.dropdown-menu');
          if (!menu) return;

          // Reset position
          menu.style.left = '0';
          menu.style.right = 'auto';

          const rect = menu.getBoundingClientRect();
          const overflowRight = rect.right - window.innerWidth;

          if (overflowRight > 0) {
            // Flip dropdown to open leftwards
            menu.style.left = 'auto';
            menu.style.right = '0';
          }
        });

        drop.addEventListener('mouseleave', () => {
          const menu = drop.querySelector('.dropdown-menu');
          if (!menu) return;
          menu.style.left = '0';
          menu.style.right = 'auto';
        });
      });
    });

    // Debt Avalanche Calculator JavaScript (from DevAvalanche007.html)
    let balanceLineChart;

    function addDebt() {
      const tbody = document.getElementById("debtBody");
      if (tbody.children.length >= 20) {
        alert("Maximum 20 debts allowed.");
        return;
      }
      const row = document.createElement("tr");
      row.innerHTML = `
        <td><input type="text" class="cred" placeholder="Creditor"></td>
        <td><input type="number" class="bal" step="0.01" min="0"></td>
        <td><input type="number" class="rate" step="0.01" min="0"></td>
        <td><input type="number" class="min" step="0.01" min="0"></td>
        <td>
          <select class="type">
            <option value="£">£</option>
            <option value="%">%</option>
          </select>
        </td>
        <td><button onclick="this.closest('tr').remove()" aria-label="Remove debt">❌</button></td>
      `;
      tbody.appendChild(row);
    }

    function getDebts() {
      const rows = document.querySelectorAll("#debtBody tr");
      const debts = [];
      rows.forEach((row, i) => {
        const creditor = row.querySelector(".cred").value.trim() || `Debt ${i + 1}`;
        const balance = parseFloat(row.querySelector(".bal").value);
        const rate = parseFloat(row.querySelector(".rate").value);
        const min = parseFloat(row.querySelector(".min").value);
        const type = row.querySelector(".type").value;

        if (isNaN(balance) || isNaN(rate) || isNaN(min)) return;

        debts.push({
          creditor,
          balance,
          rate,
          minInputValue: min,
          minType: type,
          originalBalance: balance
        });
      });
      return debts;
    }

    // Function to calculate months and total interest for a single debt with minimum payments
    function calculateMinPaymentScenario(initialBalance, minPayInput, minType, rate) {
        let balance = initialBalance;
        let months = 0;
        let totalInterestPaid = 0;

        while (balance > 0 && months < 600) { // Cap at 50 years to prevent infinite loops
            let minPayment = minType === "%" ? balance * minPayInput / 100 : minPayInput;
            if (minPayment < 1 && minType === "%") minPayment = 1; // Minimum floor for %

            const interest = balance * rate / 1200;
            const principal = minPayment - interest;

            if (minPayment <= interest && balance > 0.01) { // If min payment doesn't cover interest (and balance is not negligible)
                months = Infinity; // Indicates it will never be paid off with min payments
                totalInterestPaid = Infinity;
                break;
            }

            totalInterestPaid += interest;
            balance -= principal;
            months++;

            if (balance <= 0.01) { // Account for floating point inaccuracies
                balance = 0;
            }
        }
        return { months, totalInterestPaid };
    }

    function calculate() {
      const extra = parseFloat(document.getElementById("extraBudget").value) || 0;
      const debtsInput = getDebts();
      if (debtsInput.length === 0) {
        alert("Please add at least one debt.");
        return;
      }

      // --- Calculate Minimum Payment Scenario for overall summary ---
      let totalMinPaymentMonths = 0;
      let totalMinPaymentInterest = 0;
      let minPaymentIndividualDurations = [];

      debtsInput.forEach(d => {
        const { months, totalInterestPaid } = calculateMinPaymentScenario(d.balance, d.minInputValue, d.minType, d.rate);
        minPaymentIndividualDurations.push({ creditor: d.creditor, months, totalInterestPaid });

        // For overall summary, we sum up if each is finite. If any is infinite, the total is infinite.
        if (months === Infinity) {
            totalMinPaymentMonths = Infinity;
            totalMinPaymentInterest = Infinity;
        } else if (totalMinPaymentMonths !== Infinity) { // Only sum if not already infinite
            totalMinPaymentMonths = Math.max(totalMinPaymentMonths, months); // Max duration if paid individually
            totalMinPaymentInterest += totalInterestPaid;
        }
      });


      let activeDebts = debtsInput.map(d => ({
        creditor: d.creditor,
        rate: d.rate,
        balance: d.balance,
        originalBalance: d.originalBalance,
        minInputValue: d.minInputValue,
        minType: d.minType,
        minPayment: 0,
        totalPaidThisMonth: 0,
      }));

      let month = 0;
      let paymentsSchedule = [];
      let balancesOverTime = activeDebts.map(d => [d.originalBalance]);
      let totalBalances = [activeDebts.reduce((sum, d) => sum + d.originalBalance, 0)];
      let totalInterestPaidAvalanche = 0;

      // NEW: fixed initial total monthly payment budget (minimums + extra)
      let initialMonthlyBudget = null;

      while (activeDebts.some(d => d.balance > 0) && month < 500) { // Max 500 months (approx 41 years)
        month++;

        // 1) Recalculate minimum payments for % debts based on current balance
        let monthlyMinSum = 0;
        activeDebts.forEach(d => {
          if (d.balance <= 0) {
            d.minPayment = 0;
          } else if (d.minType === "%") {
            d.minPayment = d.balance * (d.minInputValue / 100);
            if (d.minPayment < 1) d.minPayment = 1; // minimum floor
            if (d.minPayment > d.balance) d.minPayment = d.balance; // Don't pay more than balance
          } else {
            d.minPayment = d.minInputValue;
            if (d.minPayment > d.balance) d.minPayment = d.balance; // Don't pay more than balance
          }
          monthlyMinSum += d.minPayment;
          d.totalPaidThisMonth = 0; // reset before payment calc
        });

        // 2) Set fixed monthly budget from first month (min payments + extra)
        if (initialMonthlyBudget === null) {
          initialMonthlyBudget = monthlyMinSum + extra;
        }

        // Use fixed monthly budget each month
        let monthlyBudget = initialMonthlyBudget;

        // 3) If total remaining balances < monthlyBudget, final payment is smaller
        const totalBalanceRemaining = activeDebts.reduce((sum, d) => sum + d.balance, 0);
        if (totalBalanceRemaining < monthlyBudget) {
          monthlyBudget = totalBalanceRemaining; // last smaller payment
        }

        // 4) Pay minimums first and apply interest
        let paymentsThisMonth = {};
        let paymentsSum = 0; // Tracks total actually paid this month

        // Store interest for this month before applying minimums
        let currentMonthInterest = 0;
        activeDebts.forEach(d => {
            if (d.balance > 0) {
                const interest = d.balance * d.rate / 1200;
                currentMonthInterest += interest;
            }
        });
        totalInterestPaidAvalanche += currentMonthInterest;


        activeDebts.forEach(d => {
          if (d.balance <= 0) {
            paymentsThisMonth[d.creditor] = 0;
            return;
          }
          // The minimum payment might not cover interest, leading to balance growth.
          // This calculation assumes the min payment is made and interest is added.
          // The `principal` variable below handles actual balance reduction.
          const interestPortionOfMinPayment = Math.min(d.minPayment, d.balance * d.rate / 1200);

          // The actual principal reduction from the minimum payment
          let principalPaidByMin = d.minPayment - (d.balance * d.rate / 1200);
          if (principalPaidByMin < 0) principalPaidByMin = 0; // If min payment doesn't cover interest, no principal is paid by min.

          d.balance = d.balance * (1 + d.rate / 1200) - d.minPayment;

          if (d.balance < 0.01 && d.balance > -0.01) d.balance = 0; // Clamp small negatives to 0

          paymentsThisMonth[d.creditor] = d.minPayment;
          paymentsSum += d.minPayment;
          d.totalPaidThisMonth += d.minPayment;
        });

        // 5) Apply leftover budget (monthlyBudget - paymentsSum) to highest interest debts
        let leftover = monthlyBudget - paymentsSum;

        // Sort debts by rate desc, balance desc
        let prioritizedDebts = activeDebts.filter(d => d.balance > 0).sort((a, b) => {
          if (b.rate !== a.rate) return b.rate - a.rate;
          return b.balance - a.balance;
        });

        for (let d of prioritizedDebts) {
          if (leftover <= 0) break;

          const paymentToDebt = Math.min(d.balance, leftover);
          d.balance -= paymentToDebt;
          d.totalPaidThisMonth += paymentToDebt;

          paymentsThisMonth[d.creditor] += paymentToDebt;
          paymentsSum += paymentToDebt;
          leftover -= paymentToDebt;
        }

        // Clamp balances to zero minimum
        activeDebts.forEach(d => { if (d.balance < 0) d.balance = 0; });

        paymentsSchedule.push({ month, payments: { ...paymentsThisMonth }, total: paymentsSum });

        // Update balancesOverTime and totalBalances for the current month
        balancesOverTime.forEach((balArr, idx) => {
          balArr.push(activeDebts[idx].balance);
        });
        totalBalances.push(activeDebts.reduce((sum, d) => sum + d.balance, 0));
      }

      const totalAvalancheMonths = month;

      // --- Display Summary ---
      const minSummaryDiv = document.getElementById("minimumSummary");
      minSummaryDiv.innerHTML = "<h3>Individual Debt Payoff with Minimum Payments:</h3>";

      minPaymentIndividualDurations.forEach(d => {
        const displayMonths = d.months === Infinity
          ? "an indefinite period (minimum payment insufficient to cover interest)"
          : `${d.months} months`;
        const displayInterest = d.totalInterestPaid === Infinity
          ? "Indefinite"
          : `£${d.totalInterestPaid.toFixed(2)}`;
        const para = document.createElement("p");
        para.textContent = `Paying only the minimum on "${d.creditor}" will take approximately ${displayMonths} to clear, costing ${displayInterest} in interest.`;
        minSummaryDiv.appendChild(para);
      });

      // Overall Summary
      minSummaryDiv.innerHTML += "<h3>Overall Debt Strategy Comparison:</h3>";

      const overallMinMonthsPara = document.createElement("p");
      if (totalMinPaymentMonths === Infinity) {
          overallMinMonthsPara.textContent = `Paying only minimums across all debts, at least one debt will never be paid off (or take an extremely long time), and total interest will be indefinite.`;
          minSummaryDiv.appendChild(overallMinMonthsPara);
      } else {
          overallMinMonthsPara.textContent = `Paying only minimums across all debts would take approximately ${totalMinPaymentMonths} months and cost £${totalMinPaymentInterest.toFixed(2)} in total interest.`;
          minSummaryDiv.appendChild(overallMinMonthsPara);

          const avalancheSummaryPara = document.createElement("p");
          avalancheSummaryPara.textContent = `Using the Debt Avalanche method with your extra £${extra.toFixed(2)} budget, you can be debt-free in approximately ${totalAvalancheMonths} months, paying a total of £${totalInterestPaidAvalanche.toFixed(2)} in interest.`;
          minSummaryDiv.appendChild(avalancheSummaryPara);

          const monthsSaved = totalMinPaymentMonths - totalAvalancheMonths;
          const interestSaved = totalMinPaymentInterest - totalInterestPaidAvalanche;

          const savingsPara = document.createElement("p");
          savingsPara.innerHTML = `This means you could save approximately <strong>${monthsSaved} months</strong> on your debt journey and save a significant <strong>£${interestSaved.toFixed(2)}</strong> in interest!`;
          minSummaryDiv.appendChild(savingsPara);
      }


      const baseLabels = debtsInput.map(d => d.creditor);

      drawBalanceLineChart(totalBalances, balancesOverTime, baseLabels);
      buildHorizontalTable("paymentScheduleTable", paymentsSchedule, baseLabels, false);

      let balanceSchedule = paymentsSchedule.map(row => {
        let balRow = { month: row.month, balances: {} };
        activeDebts.forEach((d, i) => {
          balRow.balances[d.creditor] = balancesOverTime[i][row.month];
        });
        balRow.total = totalBalances[row.month];
        return balRow;
      });
      buildHorizontalTable("balanceScheduleTable", balanceSchedule, baseLabels, true);
    }

    function buildHorizontalTable(tableId, dataRows, creditors, isBalance) {
      const table = document.getElementById(tableId);
      const thead = table.querySelector("thead tr");
      const tbody = table.querySelector("tbody");

      thead.innerHTML = "";
      tbody.innerHTML = "";

      thead.appendChild(createCell("Month", "th"));
      creditors.forEach(c => thead.appendChild(createCell(c, "th")));
      thead.appendChild(createCell(isBalance ? "Total Balance" : "Total Payment", "th"));

      dataRows.forEach(row => {
        const tr = document.createElement("tr");
        tr.appendChild(createCell(row.month, "td"));
        creditors.forEach(c => {
          let val = isBalance
            ? (row.balances ? row.balances[c] : 0)
            : (row.payments ? row.payments[c] : 0);
          val = val || 0;
          tr.appendChild(createCell("£" + val.toFixed(2), "td"));
        });
        tr.appendChild(createCell("£" + (row.total || 0).toFixed(2), "td"));
        tbody.appendChild(tr);
      });
    }

    function createCell(text, type = "td") {
      const cell = document.createElement(type);
      cell.textContent = text;
      return cell;
    }

    function drawBalanceLineChart(totalBalances, balancesOverTime, debtLabels) {
      const ctx = document.getElementById("balanceLineChart").getContext("2d");

      const months = Array.from({ length: totalBalances.length }, (_, i) => i);

      // Draw total balance first with light fill, then individual debts on top
      const datasets = [
        {
          label: "Total Balance",
          data: totalBalances,
          borderColor: "#0071e3",
          backgroundColor: "rgba(0, 113, 227, 0.15)", // translucent fill
          fill: true,
          tension: 0.2,
          borderWidth: 2,
          pointRadius: 0,
          order: 1, // draw first so below individual lines
        },
      ];

      balancesOverTime.forEach((balances, i) => {
        datasets.push({
          label: debtLabels[i],
          data: balances,
          borderColor: getColor(i),
          fill: false,
          tension: 0.2,
          borderWidth: 3, // thicker for visibility
          pointRadius: 0,
          borderDash: [],
          order: 2, // draw on top
        });
      });

      if (balanceLineChart) {
        balanceLineChart.destroy();
      }

      balanceLineChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: months,
          datasets: datasets,
        },
        options: {
          responsive: true,
          interaction: {
            mode: "index",
            intersect: false,
          },
          plugins: {
            legend: {
              labels: {
                color: "#1d1d1f",
                font: { weight: "600" },
              },
            },
            tooltip: {
              enabled: true,
              callbacks: {
                label: ctx => `£${ctx.parsed.y.toFixed(2)}`,
              },
            },
          },
          scales: {
            x: {
              title: {
                display: true,
                text: "Months",
                color: "#3a3a3c",
              },
              ticks: {
                color: "#3a3a3c",
              },
              grid: {
                display: false,
              },
            },
            y: {
              title: {
                display: true,
                text: "Balance (£)",
                color: "#3a3a3c",
              },
              ticks: {
                color: "#3a3a3c",
              },
              grid: {
                color: "#e5e5ea",
              },
            },
          },
        },
      });
    }

    // Add initial 3 sample debts on load
    window.onload = () => {
      addDebt();
      addDebt();
      addDebt();

      const rows = document.querySelectorAll("#debtBody tr");
      if (rows.length >= 3) {
        rows[0].querySelector(".cred").value = "Credit Card A";
        rows[0].querySelector(".bal").value = "3500";
        rows[0].querySelector(".rate").value = "18.5";
        rows[0].querySelector(".min").value = "100";
        rows[0].querySelector(".type").value = "£";

        rows[1].querySelector(".cred").value = "Credit Card B";
        rows[1].querySelector(".bal").value = "2700";
        rows[1].querySelector(".rate").value = "21.0";
        rows[1].querySelector(".min").value = "75";
        rows[1].querySelector(".type").value = "£";

        rows[2].querySelector(".cred").value = "Store Card C";
        rows[2].querySelector(".bal").value = "1900";
        rows[2].querySelector(".rate").value = "30.5"; // Increased rate for better example of avalanche
        rows[2].querySelector(".min").value = "3";
        rows[2].querySelector(".type").value = "%";
      }
    };

    function getColor(i) {
      const colors = [
        "#ff3b30", // red
        "#ff9500", // orange
        "#ffcc00", // yellow
        "#4cd964", // green
        "#5ac8fa", // blue
        "#5856d6", // purple
        "#ff2d55", // pink
        "#007aff", // ios blue
        "#34c759", // ios green
        "#ff9f0a", // ios orange
      ];
      return colors[i % colors.length];
    }
  
async function downloadPDF() {
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF('p', 'pt', 'a4');

  const elements = [
    document.querySelector("#balanceLineChart"),
    document.querySelector("#paymentScheduleTable"),
    document.querySelector("#balanceScheduleTable")
  ];

  for (let i = 0; i < elements.length; i++) {
    const el = elements[i];
    const canvas = await html2canvas(el, { scale: 2 });
    const imgData = canvas.toDataURL('image/png');
    const imgWidth = 500;
    const imgHeight = (canvas.height * imgWidth) / canvas.width;

    if (i !== 0) pdf.addPage();
    pdf.addImage(imgData, 'PNG', 50, 50, imgWidth, imgHeight);
  }

  pdf.save("Debt_Avalanche_Report.pdf");
}
</script>
</body>
</html>
